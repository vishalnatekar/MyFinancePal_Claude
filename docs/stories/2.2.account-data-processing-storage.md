# Story 2.2: Account Data Processing and Storage

## Status
Approved

## Story
**As a** user,
**I want** my account data to be accurately processed and stored,
**so that** I can trust the financial information displayed.

## Acceptance Criteria
1. Raw API data transformed into unified internal data model
2. Account balances, transaction history, and holdings properly parsed
3. Data validation rules ensuring financial data accuracy
4. Duplicate transaction detection and handling
5. Currency normalization for multi-currency accounts
6. Account categorization (checking, savings, investment, credit)
7. Historical data preservation for trend analysis
8. Data encryption at rest using AES-256
9. Automated data sync scheduling with manual refresh option

## Tasks / Subtasks

- [ ] Task 1: Implement TrueLayer data transformation service (AC: 1, 2)
  - [ ] Create TrueLayerDataProcessor class for API response transformation
  - [ ] Build account data mapper from TrueLayer to internal data model
  - [ ] Implement transaction data parsing and normalization
  - [ ] Add balance parsing and precision handling for financial amounts
  - [ ] Create comprehensive data transformation tests

- [ ] Task 2: Build data validation and integrity service (AC: 3)
  - [ ] Implement Zod schemas for financial data validation
  - [ ] Add balance validation rules (non-negative for assets, etc.)
  - [ ] Create transaction amount and date validation
  - [ ] Build account type validation and normalization
  - [ ] Add data integrity checks for corrupted API responses

- [ ] Task 3: Implement duplicate transaction detection (AC: 4)
  - [ ] Create transaction fingerprinting algorithm (amount + date + merchant)
  - [ ] Build duplicate detection service with fuzzy matching
  - [ ] Implement duplicate resolution strategies (keep latest, merge, flag)
  - [ ] Add user interface for reviewing potential duplicates
  - [ ] Create background job for periodic duplicate cleanup

- [ ] Task 4: Add currency normalization and conversion (AC: 5)
  - [ ] Implement currency detection from TrueLayer account data
  - [ ] Build currency conversion service with exchange rates
  - [ ] Add GBP normalization for multi-currency accounts
  - [ ] Create currency display formatting utilities
  - [ ] Handle historical exchange rates for transaction history

- [ ] Task 5: Build automated account categorization (AC: 6)
  - [ ] Implement account type detection from TrueLayer metadata
  - [ ] Create mapping rules for institution-specific account types
  - [ ] Add manual account type override functionality
  - [ ] Build account categorization UI for user corrections
  - [ ] Create account type validation and consistency checks

- [ ] Task 6: Implement historical data preservation (AC: 7)
  - [ ] Create account balance history tracking
  - [ ] Build transaction history retention policies
  - [ ] Implement incremental data updates to preserve history
  - [ ] Add data archiving for long-term trend analysis
  - [ ] Create data export functionality for historical records

- [ ] Task 7: Enhance data encryption and security (AC: 8)
  - [ ] Validate existing AES-256 encryption for sensitive financial data
  - [ ] Implement field-level encryption for transaction details
  - [ ] Add encryption for account numbers and sensitive metadata
  - [ ] Create secure data access patterns with proper decryption
  - [ ] Add encryption key rotation capability

- [ ] Task 8: Build automated sync scheduling system (AC: 9)
  - [ ] Enhance existing 6-hour sync with intelligent scheduling
  - [ ] Implement manual refresh functionality with rate limiting
  - [ ] Add priority syncing for recently active accounts
  - [ ] Create sync conflict resolution for concurrent updates
  - [ ] Build sync status tracking and user notifications

## Dev Notes

### Previous Story Insights
From Story 2.1: TrueLayer integration completed with OAuth flow, account connection, and basic sync service. Raw TrueLayer data is being fetched and stored. Now need to process, validate, and normalize this data for reliable financial calculations.

### TrueLayer Data Processing
**Raw Data Structure** [Source: architecture/external-apis.md#truelayer-api]:
TrueLayer provides structured financial data that needs transformation:
- Account data: balances, metadata, account types
- Transaction data: amounts, merchants, categories, dates
- Currency information: GBP, EUR, USD support

**Data Transformation Pipeline**:
```typescript
class TrueLayerDataProcessor {
  async processAccountData(rawAccount: TrueLayerAccount): Promise<FinancialAccount> {
    return {
      id: generateId(),
      user_id: userId,
      truelayer_account_id: rawAccount.account_id,
      account_type: this.normalizeAccountType(rawAccount.account_type),
      account_name: rawAccount.display_name,
      institution_name: rawAccount.provider.display_name,
      current_balance: this.normalizeAmount(rawAccount.balance.current),
      currency: rawAccount.balance.currency,
      is_manual: false,
      last_synced: new Date().toISOString()
    };
  }

  async processTransactionData(rawTransaction: TrueLayerTransaction): Promise<Transaction> {
    // Transform raw transaction to internal model
  }
}
```

### Data Models and Validation
**Financial Account Validation** [Source: architecture/data-models.md#financialaccount]:
```typescript
const FinancialAccountSchema = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  truelayer_account_id: z.string().optional(),
  account_type: z.enum(['checking', 'savings', 'investment', 'credit']),
  account_name: z.string().min(1).max(100),
  institution_name: z.string().min(1).max(100),
  current_balance: z.number().finite(),
  currency: z.string().length(3), // ISO 4217
  is_shared: z.boolean(),
  is_manual: z.boolean(),
  last_synced: z.string().datetime().optional()
});
```

**Transaction Validation Schema**:
```typescript
const TransactionSchema = z.object({
  id: z.string().uuid(),
  account_id: z.string().uuid(),
  truelayer_transaction_id: z.string().optional(),
  amount: z.number().finite(),
  merchant_name: z.string().optional(),
  category: z.string().optional(),
  date: z.string().date(),
  description: z.string().optional(),
  is_shared_expense: z.boolean().default(false),
  manual_override: z.boolean().default(false)
});
```

### Duplicate Detection Algorithm
**Transaction Fingerprinting**:
```typescript
class DuplicateDetectionService {
  generateFingerprint(transaction: Transaction): string {
    // Create hash of amount + date + merchant for duplicate detection
    const key = `${transaction.amount}_${transaction.date}_${transaction.merchant_name || 'unknown'}`;
    return crypto.createHash('sha256').update(key).digest('hex');
  }

  async detectDuplicates(newTransaction: Transaction): Promise<Transaction[]> {
    // Find potential duplicates within 3-day window
    const fingerprint = this.generateFingerprint(newTransaction);
    const dateRange = this.getDateRange(newTransaction.date, 3);

    return await this.findSimilarTransactions(fingerprint, dateRange);
  }
}
```

### Currency Handling
**Multi-Currency Support**:
```typescript
class CurrencyService {
  async normalizeToGBP(amount: number, fromCurrency: string): Promise<number> {
    if (fromCurrency === 'GBP') return amount;

    const exchangeRate = await this.getExchangeRate(fromCurrency, 'GBP');
    return amount * exchangeRate;
  }

  async getExchangeRate(from: string, to: string): Promise<number> {
    // Use exchange rate API or fallback to stored rates
  }
}
```

### Data Processing Architecture
**Processing Pipeline** [Source: architecture/backend-architecture.md#service-architecture]:
```typescript
class AccountDataProcessor {
  async processAccountSync(userId: string, accountId: string): Promise<void> {
    // 1. Fetch raw data from TrueLayer
    const rawData = await this.trueLayerService.getAccountData(accountId);

    // 2. Transform to internal model
    const processedData = await this.dataProcessor.transformAccountData(rawData);

    // 3. Validate data integrity
    const validatedData = await this.validator.validateAccountData(processedData);

    // 4. Detect and handle duplicates
    const deduplicatedData = await this.duplicateDetector.processTransactions(validatedData.transactions);

    // 5. Store in database
    await this.repository.updateAccountData(validatedData, deduplicatedData);

    // 6. Update sync status
    await this.syncTracker.markSyncComplete(accountId);
  }
}
```

### File Locations
**New files to create**:
- `src/services/truelayer-data-processor.ts` - TrueLayer data transformation
- `src/services/data-validation-service.ts` - Financial data validation
- `src/services/duplicate-detection-service.ts` - Transaction duplicate handling
- `src/services/currency-service.ts` - Currency conversion and normalization
- `src/services/account-categorization-service.ts` - Account type classification
- `src/lib/financial-validators.ts` - Zod schemas for financial data
- `src/lib/currency-utils.ts` - Currency formatting and conversion utilities
- `src/lib/data-encryption-service.ts` - Field-level encryption for sensitive data
- `src/app/api/accounts/[id]/sync/route.ts` - Manual account sync endpoint
- `src/app/api/data/validate/route.ts` - Data validation endpoint
- `src/components/accounts/SyncStatus.tsx` - Sync status display component
- `src/components/accounts/DuplicateResolver.tsx` - Duplicate transaction resolver
- `src/hooks/use-account-sync.ts` - Account sync management hook

**Files to modify**:
- `src/services/account-sync-service.ts` - Enhance with data processing pipeline
- `src/types/account.ts` - Add validation and processing types
- `src/types/truelayer.ts` - Add processing-specific TrueLayer types
- `database/schema.sql` - Add data processing tables and indexes

### Database Schema Updates
**Historical Data Tracking**:
```sql
-- Account balance history
CREATE TABLE public.account_balance_history (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  account_id UUID REFERENCES public.financial_accounts(id) ON DELETE CASCADE,
  balance DECIMAL(15,2) NOT NULL,
  currency TEXT NOT NULL,
  recorded_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Transaction processing metadata
CREATE TABLE public.transaction_processing_metadata (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  transaction_id UUID REFERENCES public.transactions(id) ON DELETE CASCADE,
  fingerprint TEXT NOT NULL,
  duplicate_cluster_id UUID,
  processing_status TEXT CHECK (processing_status IN ('pending', 'processed', 'duplicate', 'error')),
  processed_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Data sync tracking
CREATE TABLE public.data_sync_logs (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  account_id UUID REFERENCES public.financial_accounts(id) ON DELETE CASCADE,
  sync_type TEXT CHECK (sync_type IN ('manual', 'scheduled', 'retry')),
  status TEXT CHECK (status IN ('started', 'processing', 'completed', 'failed')),
  transactions_processed INTEGER DEFAULT 0,
  duplicates_found INTEGER DEFAULT 0,
  errors_encountered TEXT[],
  started_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  completed_at TIMESTAMP WITH TIME ZONE
);

-- Indexes for performance
CREATE INDEX idx_balance_history_account_date ON public.account_balance_history(account_id, recorded_at DESC);
CREATE INDEX idx_transaction_fingerprint ON public.transaction_processing_metadata(fingerprint);
CREATE INDEX idx_sync_logs_account_status ON public.data_sync_logs(account_id, status);
```

### Technical Constraints
**Data Integrity Requirements**:
- All financial amounts must be validated and stored with proper precision
- Transaction dates must be validated and normalized to UTC
- Currency codes must follow ISO 4217 standards
- Duplicate detection must handle edge cases (pending transactions, etc.)

**Performance Requirements**:
- Batch processing for large transaction sets (>1000 transactions)
- Incremental updates to preserve processing history
- Efficient duplicate detection with proper indexing
- Background processing to avoid blocking user interactions

**Security Requirements** [Source: architecture/backend-architecture.md#authentication-and-authorization]:
- Field-level encryption for sensitive transaction data
- Secure access patterns for decrypting financial information
- Audit logging for all data processing operations
- Rate limiting on manual sync operations

### Testing Requirements
**Data Processing Tests** [Source: architecture/testing-strategy.md]:
- **Unit Tests**: Data transformation, validation, duplicate detection
  - Location: `tests/services/truelayer-data-processor.test.ts`
- **Integration Tests**: End-to-end data processing pipeline
  - Location: `tests/integration/data-processing.test.ts`
- **Performance Tests**: Large dataset processing
  - Location: `tests/performance/data-processing.test.ts`

**Test Scenarios**:
- TrueLayer API response transformation
- Data validation with invalid/corrupted data
- Duplicate detection with various transaction patterns
- Currency conversion accuracy
- Account categorization edge cases
- Historical data preservation during updates

### Error Handling and Recovery
**Data Processing Error Patterns**:
```typescript
class DataProcessingError extends Error {
  constructor(
    public type: 'validation' | 'transformation' | 'duplicate' | 'currency',
    public accountId: string,
    public rawData: any,
    message: string
  ) {
    super(message);
  }
}

const DATA_PROCESSING_ERROR_MESSAGES = {
  INVALID_BALANCE: {
    title: 'Invalid Account Balance',
    message: 'Account balance data appears corrupted. Manual review required.',
    action: 'Contact Support'
  },
  CURRENCY_CONVERSION_FAILED: {
    title: 'Currency Conversion Error',
    message: 'Unable to convert account currency. Using original values.',
    action: 'Retry Later'
  },
  DUPLICATE_DETECTION_FAILED: {
    title: 'Duplicate Detection Issue',
    message: 'Unable to process transaction duplicates. Some duplicates may appear.',
    action: 'Manual Review'
  }
};
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-01 | 1.0 | Initial story creation for TrueLayer data processing and storage | Scrum Master (Bob) |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*Results from QA Agent review will be populated here after implementation*